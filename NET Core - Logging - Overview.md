#net_core/Logging 

---

[Learn.MS](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line)

.NET supports a logging API that works with a variety of built-in and third-party logging providers. This article shows how to use the logging API with [built-in providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers). The logging providers are responsible for determining where logs are written to. Most of the code examples shown in this article apply to any .NET app that uses the [[NET Core - Generic Host|Generic Host]]. For apps that don't use the Generic Host, see [Non-host console app](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#non-host-console-app).

> All of the logging example source code is available in the **Samples Browser** for download. For more information, see [Browse code samples: Logging in .NET](https://learn.microsoft.com/en-us/samples/dotnet/samples/csharp-logging-fundamentals).
 
> ![[zICO - Warning - 16.png]] Starting with .NET 6, logging services no longer register the [ILogger](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) type. When using a logger, specify the generic-type alternative [`ILogger<TCategoryName>`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1) or register the `ILogger` with [dependency injection (DI)](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection).

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#create-logs)Create logs

To create logs, use an [`ILogger<TCategoryName>`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1) object from [DI](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection).

The following example:

-   Creates a logger, `ILogger<Worker>`, which uses a log _category_ of the fully qualified name of the type `Worker`. The log category is a string that is associated with each log.
-   Calls [LogInformation](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.loginformation) to log at the `Information` level. The Log _level_ indicates the severity of the logged event.

```cs
public sealed class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;

    public Worker(ILogger<Worker> logger) =>
        _logger = logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation("Worker running at: {time}", DateTimeOffset.UtcNow);
            await Task.Delay(1_000, stoppingToken);
        }
    }
}
```

[Levels](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-level) and [categories](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-category) are explained in more detail later in this article.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#configure-logging)Configure logging

Logging configuration is commonly provided by the `Logging` section of _appsettings_.`{Environment}`_.json_ files. The following _appsettings.Development.json_ file is generated by the .NET Worker service templates:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}
```

In the preceding JSON:

-   The `"Default"`, `"Microsoft"`, and `"Microsoft.Hosting.Lifetime"` log level categories are specified.
-   The `"Default"` value is applied to all categories that aren't otherwise specified, effectively making all default values for all categories `"Information"`. You can override this behavior by specifying a value for a category.
-   The `"Microsoft"` category applies to all categories that start with `"Microsoft"`.
-   The `"Microsoft"` category logs at a log level of `Warning` and higher.
-   The `"Microsoft.Hosting.Lifetime"` category is more specific than the `"Microsoft"` category, so the `"Microsoft.Hosting.Lifetime"` category logs at log level `"Information"` and higher.
-   A specific log provider is not specified, so `LogLevel` applies to all the enabled logging providers except for the [Windows EventLog](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers#windows-eventlog).

The `Logging` property can have [LogLevel](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel) and log provider properties. The `LogLevel` specifies the minimum [level](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-level) to log for selected categories. In the preceding JSON, `Information` and `Warning` log levels are specified. `LogLevel` indicates the severity of the log and ranges from 0 to 6:

`Trace` = 0, `Debug` = 1, `Information` = 2, `Warning` = 3, `Error` = 4, `Critical` = 5, and `None` = 6.

When a `LogLevel` is specified, logging is enabled for messages at the specified level and higher. In the preceding JSON, the `Default` category is logged for `Information` and higher. For example, `Information`, `Warning`, `Error`, and `Critical` messages are logged. If no `LogLevel` is specified, logging defaults to the `Information` level. For more information, see [Log levels](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-level).

A provider property can specify a `LogLevel` property. `LogLevel` under a provider specifies levels to log for that provider, and overrides the non-provider log settings. Consider the following _appsettings.json_ file:

```json
{
    "Logging": {
        "LogLevel": {
            "Default": "Error",
            "Microsoft": "Warning"
        },
        "Debug": {
            "LogLevel": {
                "Default": "Information",
                "Microsoft.Hosting": "Trace"
            }
        },
        "EventSource": {
            "LogLevel": {
                "Default": "Warning"
            }
        }
    }
}
```

Settings in `Logging.{ProviderName}.LogLevel` override settings in `Logging.LogLevel`. In the preceding JSON, the `Debug` provider's default log level is set to `Information`:

`Logging:Debug:LogLevel:Default:Information`

The preceding setting specifies the `Information` log level for every `Logging:Debug:` category except `Microsoft.Hosting`. When a specific category is listed, the specific category overrides the default category. In the preceding JSON, the `Logging:Debug:LogLevel` categories `"Microsoft.Hosting"` and `"Default"` override the settings in `Logging:LogLevel`

The minimum log level can be specified for any of:

-   Specific providers: For example, `Logging:EventSource:LogLevel:Default:Information`
-   Specific categories: For example, `Logging:LogLevel:Microsoft:Warning`
-   All providers and all categories: `Logging:LogLevel:Default:Warning`

Any logs below the minimum level are _**not**_:

-   Passed to the provider.
-   Logged or displayed.

To suppress all logs, specify [LogLevel.None](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel). `LogLevel.None` has a value of 6, which is higher than `LogLevel.Critical` (5).

If a provider supports [log scopes](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-scopes), `IncludeScopes` indicates whether they're enabled. For more information, see [log scopes](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-scopes)

The following _appsettings.json_ file contains settings for all of the built-in providers:

```json
{
    "Logging": {
        "LogLevel": {
            "Default": "Error",
            "Microsoft": "Warning",
            "Microsoft.Hosting.Lifetime": "Warning"
        },
        "Debug": {
            "LogLevel": {
                "Default": "Information"
            }
        },
        "Console": {
            "IncludeScopes": true,
            "LogLevel": {
                "Microsoft.Extensions.Hosting": "Warning",
                "Default": "Information"
            }
        },
        "EventSource": {
            "LogLevel": {
                "Microsoft": "Information"
            }
        },
        "EventLog": {
            "LogLevel": {
                "Microsoft": "Information"
            }
        },
        "AzureAppServicesFile": {
            "IncludeScopes": true,
            "LogLevel": {
                "Default": "Warning"
            }
        },
        "AzureAppServicesBlob": {
            "IncludeScopes": true,
            "LogLevel": {
                "Microsoft": "Information"
            }
        },
        "ApplicationInsights": {
            "LogLevel": {
                "Default": "Information"
            }
        }
    }
}
```

In the preceding sample:

-   The categories and levels are not suggested values. The sample is provided to show all the default providers.
-   Settings in `Logging.{ProviderName}.LogLevel` override settings in `Logging.LogLevel`. For example, the level in `Debug.LogLevel.Default` overrides the level in `LogLevel.Default`.
-   Each provider's _alias_ is used. Each provider defines an _alias_ that can be used in configuration in place of the fully qualified type name. The built-in providers' aliases are:
    -   `Console`
    -   `Debug`
    -   `EventSource`
    -   `EventLog`
    -   `AzureAppServicesFile`
    -   `AzureAppServicesBlob`
    -   `ApplicationInsights`

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#set-log-level-by-command-line-environment-variables-and-other-configuration)Set log level by command line, environment variables, and other configuration

Log level can be set by any of the [configuration providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers). For example, you can create a persisted environment variable named `Logging:LogLevel:Microsoft` with a value of `Information`.

-   [Command Line](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#tabpanel_1_command-line)
-   [PowerShell](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#tabpanel_1_powershell)
-   [Bash](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#tabpanel_1_bash)

Create and assign persisted environment variable, given the log level value.

```bat
:: Assigns the env var to the value
setx "Logging__LogLevel__Microsoft" "Information" /M
```

In a _new_ instance of the **Command Prompt**, read the environment variable.

```bat
:: Prints the env var value
echo %Logging__LogLevel__Microsoft%
```

The preceding environment setting is persisted in the environment. To test the settings when using an app created with the .NET Worker service templates, use the `dotnet run` command in the project directory after the environment variable is assigned.

```bat
dotnet run
```

> After setting an environment variable, restart your integrated development environment (IDE) to ensure that newly added environment variables are available.

On [Azure App Service](https://azure.microsoft.com/services/app-service/), select **New application setting** on the **Settings > Configuration** page. Azure App Service application settings are:

-   Encrypted at rest and transmitted over an encrypted channel.
-   Exposed as environment variables.

For more information on setting .NET configuration values using environment variables, see [environment variables](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers#environment-variable-configuration-provider).

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#how-filtering-rules-are-applied)How filtering rules are applied

When an [`ILogger<TCategoryName>`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1) object is created, the [ILoggerFactory](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory) object selects a single rule per provider to apply to that logger. All messages written by an `ILogger` instance are filtered based on the selected rules. The most specific rule for each provider and category pair is selected from the available rules.

The following algorithm is used for each provider when an `ILogger` is created for a given category:

-   Select all rules that match the provider or its alias. If no match is found, select all rules with an empty provider.
-   From the result of the preceding step, select rules with longest matching category prefix. If no match is found, select all rules that don't specify a category.
-   If multiple rules are selected, take the **last** one.
-   If no rules are selected, use [LoggingBuilderExtensions.SetMinimumLevel(ILoggingBuilder, LogLevel)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggingbuilderextensions.setminimumlevel#microsoft-extensions-logging-loggingbuilderextensions-setminimumlevel(microsoft-extensions-logging-iloggingbuilder-microsoft-extensions-logging-loglevel)) to specify the minimum logging level.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-category)Log category

When an `ILogger` object is created, a _category_ is specified. That category is included with each log message created by that instance of `ILogger`. The category string is arbitrary, but the convention is to use the class name. For example, in an application with a service defined like the following object, the category might be `"Example.DefaultService"`:

```cs
namespace Example
{
    public class DefaultService : IService
    {
        private readonly ILogger<DefaultService> _logger;

        public DefaultService(ILogger<DefaultService> logger) =>
            _logger = logger;

        // ...
    }
}
```

To explicitly specify the category, call [LoggerFactory.CreateLogger](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory.createlogger):

```cs
namespace Example
{
    public class DefaultService : IService
    {
        private readonly ILogger _logger;

        public DefaultService(ILoggerFactory loggerFactory) =>
            _logger = loggerFactory.CreateLogger("CustomCategory");

        // ...
    }
}
```

Calling `CreateLogger` with a fixed name can be useful when used in multiple classes/types so the events can be organized by category.

`ILogger<T>` is equivalent to calling `CreateLogger` with the fully qualified type name of `T`.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-level)Log level

The following table lists the [LogLevel](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel) values, the convenience `Log{LogLevel}` extension method, and the suggested usage:

LogLevel|Value|Method|Description
--|--|--|--
[Trace](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|0|[LogTrace](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logtrace)|Contain the most detailed messages. These messages may contain sensitive app data. These messages are disabled by default and should _**not**_ be enabled in production.
[Debug](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|1|[LogDebug](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logdebug)|For debugging and development. Use with caution in production due to the high volume.
[Information](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|2|[LogInformation](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.loginformation)|Tracks the general flow of the app. May have long-term value.
[Warning](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|3|[LogWarning](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logwarning)|For abnormal or unexpected events. Typically includes errors or conditions that don't cause the app to fail.
[Error](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|4|[LogError](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logerror)|For errors and exceptions that cannot be handled. These messages indicate a failure in the current operation or request, not an app-wide failure.
[Critical](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|5|[LogCritical](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logcritical)|For failures that require immediate attention. Examples: data loss scenarios, out of disk space.
[None](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel)|6||Specifies that no messages should be written.

In the previous table, the `LogLevel` is listed from lowest to highest severity.

The [Log](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions) method's first parameter, [LogLevel](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel), indicates the severity of the log. Rather than calling `Log(LogLevel, ...)`, most developers call the [Log{LogLevel}](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions) extension methods. The `Log{LogLevel}` extension methods [call the Log method and specify the LogLevel](https://github.com/dotnet/extensions/blob/release/3.1/src/Logging/Logging.Abstractions/src/LoggerExtensions.cs). For example, the following two logging calls are functionally equivalent and produce the same log:

```cs
public void LogDetails()
{
    var logMessage = "Details for log.";

    _logger.Log(LogLevel.Information, AppLogEvents.Details, logMessage);
    _logger.LogInformation(AppLogEvents.Details, logMessage);
}
```

`AppLogEvents.Details` is the event ID, and is implicitly represented by a constant [Int32](https://learn.microsoft.com/en-us/dotnet/api/system.int32) value. `AppLogEvents` is a class that exposes various named identifier constants and is displayed in the [Log event ID](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-event-id) section.

The following code creates `Information` and `Warning` logs:

```cs
public async Task<T> GetAsync<T>(string id)
{
    _logger.LogInformation(AppLogEvents.Read, "Reading value for {Id}", id);

    var result = await _repository.GetAsync(id);
    if (result is null)
    {
        _logger.LogWarning(AppLogEvents.ReadNotFound, "GetAsync({Id}) not found", id);
    }

    return result;
}
```

In the preceding code, the first `Log{LogLevel}` parameter,`AppLogEvents.Read`, is the [Log event ID](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-event-id). The second parameter is a message template with placeholders for argument values provided by the remaining method parameters. The method parameters are explained in the [message template](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template) section later in this article.

Configure the appropriate log level and call the correct `Log{LogLevel}` methods to control how much log output is written to a particular storage medium. For example:

-   In production:
    -   Logging at the `Trace` or `Debug` levels produces a high-volume of detailed log messages. To control costs and not exceed data storage limits, log `Trace` and `Debug` level messages to a high-volume, low-cost data store. Consider limiting `Trace` and `Debug` to specific categories.
    -   Logging at `Warning` through `Critical` levels should produce few log messages.
        -   Costs and storage limits usually aren't a concern.
        -   Few logs allow more flexibility in data store choices.
-   In development:
    -   Set to `Warning`.
    -   Add `Trace` or `Debug` messages when troubleshooting. To limit output, set `Trace` or `Debug` only for the categories under investigation.

The following JSON sets `Logging:Console:LogLevel:Microsoft:Information`:

```json
{
    "Logging": {
        "LogLevel": {
            "Microsoft": "Warning"
        },
        "Console": {
            "LogLevel": {
                "Microsoft": "Information"
            }
        }
    }
}
```

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-event-id)Log event ID

Each log can specify an _event identifier_, the [EventId](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventid) is a structure with an `Id` and optional `Name` readonly properties. The sample source code uses the `AppLogEvents` class to define event IDs:

```cs
using Microsoft.Extensions.Logging;

internal static class AppLogEvents
{
    internal EventId Create = new(1000, "Created");
    internal EventId Read = new(1001, "Read");
    internal EventId Update = new(1002, "Updated");
    internal EventId Delete = new(1003, "Deleted");

    // These are also valid EventId instances, as there's
    // an implicit conversion from int to an EventId
    internal const int Details = 3000;
    internal const int Error = 3001;

    internal EventId ReadNotFound = 4000;
    internal EventId UpdateNotFound = 4001;

    // ...
}
```
 
> For more information on converting an `int` to an `EventId`, see [EventId.Implicit(Int32 to EventId) Operator](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventid.op_implicit).

An event ID associates a set of events. For example, all logs related to reading values from a repository might be `1001`.

The logging provider may log the event ID in an ID field, in the logging message, or not at all. The Debug provider doesn't show event IDs. The console provider shows event IDs in brackets after the category:

```txt
info: Example.DefaultService.GetAsync[1001]
      Reading value for a1b2c3
warn: Example.DefaultService.GetAsync[4000]
      GetAsync(a1b2c3) not found
```

Some logging providers store the event ID in a field, which allows for filtering on the ID.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template)Log message template

Each log API uses a message template. The message template can contain placeholders for which arguments are provided. Use names for the placeholders, not numbers. The order of placeholders, not their names, determines which parameters are used to provide their values. In the following code, the parameter names are out of sequence in the message template:

```cs
string p1 = "param1";
string p2 = "param2";
_logger.LogInformation("Parameter values: {p2}, {p1}", p1, p2);
```

The preceding code creates a log message with the parameter values in sequence:

```txt
Parameter values: param1, param2
```

> Be mindful when using multiple placeholders within a single message template, as they're ordinal-based. The names are _not_ used to align the arguments to the placeholders.

This approach allows logging providers to implement [semantic or structured logging](https://github.com/NLog/NLog/wiki/How-to-use-structured-logging). The arguments themselves are passed to the logging system, not just the formatted message template. This enables logging providers to store the parameter values as fields. Consider the following logger method:

```cs
_logger.LogInformation("Getting item {Id} at {RunTime}", id, DateTime.Now);
```

For example, when logging to Azure Table Storage:

-   Each Azure Table entity can have `ID` and `RunTime` properties.
-   Tables with properties simplify queries on logged data. For example, a query can find all logs within a particular `RunTime` range without having to parse the time out of the text message.

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template-formatting)Log message template formatting

Log message templates support placeholder formatting. Templates are free to specify [any valid format](https://learn.microsoft.com/en-us/dotnet/standard/base-types/formatting-types) for the given type argument. For example, consider the following `Information` logger message template:

```cs
_logger.LogInformation("Logged on {PlaceHolderName:MMMM dd, yyyy}", DateTimeOffset.UtcNow);
// Logged on January 06, 2022
```

In the preceding example, the `DateTimeOffset` instance is the type that corresponds to the `PlaceHolderName` in the logger message template. This name can be anything as the values are ordinal-based. The `MMMM dd, yyyy` format is valid for the `DateTimeOffset` type.

For more information on `DateTime` and `DateTimeOffset` formatting, see [Custom date and time format strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings).

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-message-template-formatting-examples)Log message template formatting examples

Log message templates allow placeholder formatting. The following examples show how to format a message template using the `{}` placeholder syntax. Additionally, an example of escaping the `{}` placeholder syntax is shown with its output. Finally, string interpolation with templating placeholders is also shown:

```cs
logger.LogInformation("Number: {Number}", 1);               // Number: 1
logger.LogInformation("{{Number}}: {Number}", 3);           // {Number}: 3
logger.LogInformation($"{{{{Number}}}}: {{Number}}", 5);    // {Number}: 5
```

> ![[zICO - Exclamation - 16.png]] You should always use log message template formatting when logging. You should avoid string interpolation as it can cause performance issues.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-exceptions)Log exceptions

The logger methods have overloads that take an exception parameter:

```cs
public void Test(string id)
{
    try
    {
        if (id is "none")
        {
            throw new Exception("Default Id detected.");
        }
    }
    catch (Exception ex)
    {
        _logger.LogWarning(
            AppLogEvents.Error, ex,
            "Failed to process iteration: {Id}", id);
    }
}
```

Exception logging is provider-specific.

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#default-log-level)Default log level

If the default log level is not set, the default log level value is `Information`.

For example, consider the following worker service app:

-   Created with the .NET Worker templates.
-   _appsettings.json_ and _appsettings.Development.json_ deleted or renamed.

With the preceding setup, navigating to the privacy or home page produces many `Trace`, `Debug`, and `Information` messages with `Microsoft` in the category name.

The following code sets the default log level when the default log level is not set in configuration:

```cs
using IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureLogging(logging => logging.SetMinimumLevel(LogLevel.Warning))
    .Build();

await host.RunAsync();
```

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#filter-function)Filter function

A filter function is invoked for all providers and categories that don't have rules assigned to them by configuration or code:

```cs
await Host.CreateDefaultBuilder(args)
    .ConfigureLogging(logging =>
        logging.AddFilter((provider, category, logLevel) =>
        {
            return provider.Contains("ConsoleLoggerProvider")
                && (category.Contains("Example") || category.Contains("Microsoft"))
                && logLevel >= LogLevel.Information;
        }))
    .Build()
    .RunAsync();
```

The preceding code displays console logs when the category contains `Example` or `Microsoft` and the log level is `Information` or higher.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#log-scopes)Log scopes

A _scope_ can group a set of logical operations. This grouping can be used to attach the same data to each log that's created as part of a set. For example, every log created as part of processing a transaction can include the transaction ID.

A scope:

-   Is an [IDisposable](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable) type that's returned by the [BeginScope](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger.beginscope) method.
-   Lasts until it's disposed.

The following providers support scopes:

-   `Console`
-   [AzureAppServicesFile and AzureAppServicesBlob](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservices.batchingloggeroptions.includescopes#microsoft-extensions-logging-azureappservices-batchingloggeroptions-includescopes)

Use a scope by wrapping logger calls in a `using` block:

```cs
public async Task<T> GetAsync<T>(string id)
{
    T result;
    var transactionId = Guid.NewGuid().ToString();

    using (_logger.BeginScope(new List<KeyValuePair<string, object>>
        {
            new KeyValuePair<string, object>("TransactionId", transactionId),
        }))
    {
        _logger.LogInformation(
            AppLogEvents.Read, "Reading value for {Id}", id);

        var result = await _repository.GetAsync(id);
        if (result is null)
        {
            _logger.LogWarning(
                AppLogEvents.ReadNotFound, "GetAsync({Id}) not found", id);
        }
    }

    return result;
}
```

The following JSON enables scopes for the console provider:

```json
{
    "Logging": {
        "Debug": {
            "LogLevel": {
                "Default": "Information"
            }
        },
        "Console": {
            "IncludeScopes": true,
            "LogLevel": {
                "Microsoft": "Warning",
                "Default": "Information"
            }
        },
        "LogLevel": {
            "Default": "Debug"
        }
    }
}
```

The following code enables scopes for the console provider:

```cs
await Host.CreateDefaultBuilder(args)
    .ConfigureLogging((_, logging) =>
        logging.ClearProviders()
            .AddConsole(options => options.IncludeScopes = true))
    .Build()
    .RunAsync();
```

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#non-host-console-app)Non-host console app

Logging code for apps without a [Generic Host](https://learn.microsoft.com/en-us/dotnet/core/extensions/generic-host) differs in the way [providers are added](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers#built-in-logging-providers) and [loggers are created](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#create-logs). In a non-host console app, call the provider's `Add{provider name}` extension method while creating a `LoggerFactory`:

```cs
using var loggerFactory = LoggerFactory.Create(builder =>
{
    builder
        .AddFilter("Microsoft", LogLevel.Warning)
        .AddFilter("System", LogLevel.Warning)
        .AddFilter("LoggingConsoleApp.Program", LogLevel.Debug)
        .AddConsole();
});

ILogger logger = loggerFactory.CreateLogger<Program>();
logger.LogInformation("Example log message");
```

The `loggerFactory` object is used to create an [ILogger](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) instance.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#create-logs-in-main)Create logs in Main

The following code logs in `Main` by getting an `ILogger` instance from DI after building the host:

```cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

IHost host = Host.CreateDefaultBuilder(args).Build();

var logger = host.Services.GetRequiredService<ILogger<Program>>();
logger.LogInformation("Host created.");

await host.RunAsync();
```

The preceding code relies on two NuGet packages:

-   [Microsoft.Extensions.Hosting](https://www.nuget.org/packages/Microsoft.Extensions.Hosting)
-   [Microsoft.Extensions.Logging](https://www.nuget.org/packages/Microsoft.Extensions.Logging)

Its project file would look similar to the following:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="6.0.0" />
  </ItemGroup>

</Project>
```

### [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#no-asynchronous-logger-methods)No asynchronous logger methods

Logging should be so fast that it isn't worth the performance cost of asynchronous code. If a logging datastore is slow, don't write to it directly. Consider writing the log messages to a fast store initially, then moving them to the slow store later. For example, when logging to SQL Server, don't do so directly in a `Log` method, since the `Log` methods are synchronous. Instead, synchronously add log messages to an in-memory queue and have a background worker pull the messages out of the queue to do the asynchronous work of pushing data to SQL Server.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#change-log-levels-in-a-running-app)Change log levels in a running app

The Logging API doesn't include a scenario to change log levels while an app is running. However, some configuration providers are capable of reloading configuration, which takes immediate effect on logging configuration. For example, the [File Configuration Provider](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers#file-configuration-provider) reloads logging configuration by default. If configuration is changed in code while an app is running, the app can call [IConfigurationRoot.Reload](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationroot.reload) to update the app's logging configuration.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#nuget-packages)NuGet packages

The [`ILogger<TCategoryName>`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1) and [ILoggerFactory](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory) interfaces and implementations are included in the .NET SDK. They are also available in the following NuGet packages:

-   The interfaces are in [Microsoft.Extensions.Logging.Abstractions](https://www.nuget.org/packages/Microsoft.Extensions.Logging.Abstractions).
-   The default implementations are in [Microsoft.Extensions.Logging](https://www.nuget.org/packages/microsoft.extensions.logging).

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#apply-log-filter-rules-in-code)Apply log filter rules in code

The preferred approach for setting log filter rules is by using [Configuration](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration).

The following example shows how to register filter rules in code:

```
await Host.CreateDefaultBuilder(args)
    .ConfigureLogging(logging =>
        logging.AddFilter("System", LogLevel.Debug)
            .AddFilter<DebugLoggerProvider>("Microsoft", LogLevel.Information)
            .AddFilter<ConsoleLoggerProvider>("Microsoft", LogLevel.Trace))
    .Build()
    .RunAsync();
```

`logging.AddFilter("System", LogLevel.Debug)` specifies the `System` category and log level `Debug`. The filter is applied to all providers because a specific provider was not configured.

`AddFilter<DebugLoggerProvider>("Microsoft", LogLevel.Information)` specifies:

-   The `Debug` logging provider.
-   Log level `Information` and higher.
-   All categories starting with `"Microsoft"`.

## [](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line#see-also)See also

-   [Logging providers in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/logging-providers)
-   [Implement a custom logging provider in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/custom-logging-provider)
-   [Console log formatting](https://learn.microsoft.com/en-us/dotnet/core/extensions/console-log-formatter)
-   [High-performance logging in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging)
-   Logging bugs should be created in the [github.com/dotnet/runtime](https://github.com/dotnet/runtime//issues) repo
