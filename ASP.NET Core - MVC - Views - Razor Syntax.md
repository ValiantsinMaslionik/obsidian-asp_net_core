#aspnet_core/mvc/view 

---

The Razor compiler separates the static fragments of HTML from the C# expressions, which are then handled separately in the generated class file. There are several types of expression that can be included in views, which I describe in the sections that follow.

# Understanding Directives

Directives are expressions that give instructions to the Razor view engine. 
The `@model` expression is a directive, for example, that tells the view engine to use a specific type for the view model, while the `@using` directive tells the view engine to import a namespace. Table 21-5 describes the most useful Razor directives.

Table 21-5. Useful Razor Directives

Name|Description
--|--
@model|This directive specifies the type of the view model.
@using|This directive imports a namespace.
@page|This directive denotes a Razor Page, described in Chapter 23.
@section|This directive denotes a layout section, as described in Chapter 22.
@addTagHelper|This directive adds tag helpers to a view, as described in Chapter 25.
@namespace|This directive sets the namespace for the C# class generated from a view.
@functions|This directive adds C# properties and methods to the C# class generated from a view and is commonly used in Razor Pages, as described in Chapter 23.
@attribute|This directive adds an attribute to the C# class generated from a view. I use this feature to apply authorization restrictions in Chapter 38.
@implements|This directive declares that the C# class generated from a view implements an interface. This feature is demonstrated in Chapter 36.
@inherits|This directive sets the base class for the C# class generated from a view. This feature is demonstrated in Chapter 36.
@inject|This directive provides a view with direct access to a service through dependency injection. This feature is demonstrated in Chapter 23.

# Understanding Content Expressions

Razor content expressions produce content that is included in the output generated by a view. Table 21-6 describes the most useful content expressions, which are demonstrated in the sections that follow.

Table 21-6. Useful Razor Content Expressions

Name|Description
--|--
`@<expression>`|This is the basic Razor expression, which is evaluated, and the result it produces is inserted into the response.
@if|This expression is used to select regions of content based on the result of an expression. See [[#Using Conditional Expressions]] section for examples.
@switch|This expression is used to select regions of content based on the result of an expression. See [[#Using Conditional Expressions]] section for examples.
@foreach|This expression generates the same region of content for each element in a sequence. See the [[#Enumerating Sequences]] for examples.
@{ ... }|This expression defines a code block. See the “Using Razor Code Blocks” section for an example.
@:|This expression denotes a section of content that is not enclosed in HTML elements. See the “Using Conditional Expressions” section for an example.
@try|This expression is used to catch exceptions.
@await|This expression is used to perform an asynchronous operation, the result of which is inserted into the response. See Chapter 24 for examples.

# Setting Element Content

The simplest expressions are evaluated to produce a single value that is used as the content for an HTML element in the response sent to the client. The most common type of expression inserts a value from the view model object, like these expressions from the Watersports.cshtml view file:
```html
<tr><th>Name</th><td>@Model?.Name</td></tr>
<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
```

This type of expression can read property values or invoke methods, as these examples demonstrate. Views can contain more complex expressions, but these need to be enclosed in parentheses so that the Razor compiler can differentiate between the code and static content, as shown in Listing 21-19.

## ![[zICO - Exclamation - 16.png]] **UNDERSTANDING THE USE OF THE NULL CONDITIONAL OPERATOR IN VIEWS**

When the `@Model` expression is used, the null conditional operator (the `?` operator) is required to guard against null model values, like this:
```html
<tr><th>Name</th><td>@Model?.Name</td></tr>
```

But when the `@model` is used to define the model type, a non-nullable type is required, like this:
```html
@model Product
```

In fact, the compiler will report a warning if you specify a nullable reference type in the `@model` expression. This is not the consistency it appears to be, and it reflects the way that Razor works behind the scenes. The `RazorPage<T>` class, from which generated C# view classes are derived, defines the `Model` property used in view expressions, as described in Table 21-3. The `RazorPage<T>.Model` property is defined like this:
```cs
public T? Model => ViewData == null ? default(T) : ViewData.Model;
```

This means that even though the non-nullable `Product` type is used in the `@model` expression, the type of the `Model` property, which is used in `@Model` expressions, is the nullable `Product?` type, **and it is for this reason that the null conditional operator is required** in view expressions.

Listing 21-19. Adding Expressions in the Watersports.cshtml File in the Views/Home Folder
```html
@model Product
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Watersports</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered">
				<tbody>
					<tr><th>Name</th><td>@Model?.Name</td></tr>
					<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
					<tr><th>Tax</th><td>@Model?.Price * 0.2m</td></tr>
					<tr><th>Tax</th><td>@(Model?.Price * 0.2m)</td></tr>
				</tbody>
			</table>
		</div>
	</body>
</html>
```

Use a browser to request http://localhost:5000; the response, shown in Figure 21-13, shows why parentheses are important.

Figure 21-13. Expressions with and without parentheses
![[zIMG-asp.net-mvc-views-21-13.png]]

**The Razor View compiler matches expressions conservatively and has assumed that the asterisk and the numeric value in the first expression are static content**. This problem is avoided by parentheses for the second expression.

# Setting Attribute Values

An expression can be used to set the values of element attributes, as shown in Listing 21-20.

Listing 21-20. Setting an Attribute in the Watersports.cshtml File in the Views/Home Folder
```html
@model Product
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Watersports</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered" data-id="@Model?.ProductId">
				<tbody>
					<tr><th>Name</th><td>@Model?.Name</td></tr>
					<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
					<tr><th>Tax</th><td>@Model?.Price * 0.2m</td></tr>
					<tr><th>Tax</th><td>@(Model?.Price * 0.2m)</td></tr>
				</tbody>
			</table>
		</div>
	</body>
</html>
```

I used the Razor expressions to set the value for a data attribute on the table element.

> Data attributes, which are attributes whose names are prefixed by *data-*, have been an informal way of creating custom attributes for many years and were made part of the formal standard as part of HTML5. They are most often applied so that JavaScript code can locate specific elements or so that CSS styles can be more narrowly applied.

If you request http://localhost:5000 and look at the HTML source that is sent to the browser, you will see that Razor has set the values of the attribute, like this:
```html
<table class="table table-sm table-striped table-bordered" data-id="1">
	<tbody>
		<tr><th>Name</th><td>Kayak</td></tr>
		<tr><th>Price</th><td>$275.00</td></tr>
		<tr><th>Tax</th><td>275.00 * 0.2m</td></tr>
		<tr><th>Tax</th><td>55.000</td></tr>
	</tbody>
</table>
```

# Using Conditional Expressions

Razor supports conditional expressions, which means that the output can be tailored based on the view model. This technique is at the heart of Razor and allows you to create complex and fluid responses from views that are simple to read and maintain. In Listing 21-21, I have added a conditional statement to the Watersports view.

Listing 21-21. Using an If Expression in the Watersports.cshtml File in the Views/Home Folder
```html
@model Product
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Watersports</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered" data-id="@Model?.ProductId">
				<tbody>
					@if (Model?.Price > 200) 
					{
						<tr><th>Name</th><td>Luxury @Model?.Name</td></tr>
					}
					else
					{
						<tr><th>Name</th><td>Basic @Model?.Name</td></tr>
					}
					<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
					<tr><th>Tax</th><td>@Model?.Price * 0.2m</td></tr>
					<tr><th>Tax</th><td>@(Model?.Price * 0.2m)</td></tr>
				</tbody>
			</table>
		</div>
	</body>
</html>
```

The `@` character is followed by the `if` keyword and a condition that will be evaluated at runtime. The `if` expression supports optional else and elseif clauses and is terminated with a close brace (the `}` character). If the condition is met, then the content in the if clause is inserted into the response; otherwise, the content in the else clause is used instead.

Notice that the `@` prefix **isn’t required to access a `Model` property in the condition**.
```cs
@if (Model?.Price > 200) {
```

But the `@` prefix **is required inside the `if` and `else` clauses**, like this:
```html
<tr><th>Name</th><td>Luxury @Model?.Name</td></tr>
```

Razor also supports `@switch` expressions, which can be a more concise way of handling multiple conditions, as shown in Listing 21-22.

Listing 21-22. Using a Switch Expression in the Watersports.cshtml File in the Views/Home Folder
```html
@model Product
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Watersports</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered" data-id="@Model?.ProductId">
				<tbody>
					@switch (Model?.Name) 
					{
						case "Kayak":
							<tr><th>Name</th><td>Small Boat</td></tr>
							break;
						case "Lifejacket":
							<tr><th>Name</th><td>Flotation Aid</td></tr>
							break;
						default:
							<tr><th>Name</th><td>@Model?.Name</td></tr>
							break;
					}
					<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
					<tr><th>Tax</th><td>@Model?.Price * 0.2m</td></tr>
					<tr><th>Tax</th><td>@(Model?.Price * 0.2m)</td></tr>
				</tbody>
			</table>
		</div>
	</body>
</html>
```

Conditional expressions can lead to the same blocks of content being duplicated for each result clause. In the `switch` expression, for example, each `case` clause differs only in the content of the td element, while the `tr` and `th` elements remain the same. To remove this duplication, conditional expressions can be used within an element, as shown in Listing 21-23.

Listing 21-23. Setting Content in the Watersports.cshtml File in the Views/Home Folder
```html
@model Product
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Watersports</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered" data-id="@Model?.ProductId">
				<tbody>
					<tr><th>Name</th><td>
						@switch (Model?.Name) 
						{
							case "Kayak":
								@:Small Boat
								break;
							case "Lifejacket":
								@:Flotation Aid
								break;
							default:
								@Model?.Name
								break;
						}
				</td></tr>
				<tr><th>Price</th><td>@Model?.Price.ToString("c")</td></tr>
				<tr><th>Tax</th><td>@Model?.Price * 0.2m</td></tr>
				<tr><th>Tax</th><td>@(Model?.Price * 0.2m)</td></tr>
				</tbody>
			</table>
		</div>
	</body>
</html>
```


The Razor compiler needs help with literal values that are not enclosed in HTML elements, requiring the `@:` prefix, like this:
```html
@:Small Boat
```

The compiler copes with HTML elements because it detects the open tag, but this additional help is required for text content.

# Enumerating Sequences

The Razor `@foreach` expression generates content for each object in an array or a collection, which is a common requirement when processing data. Listing 21-24 adds an action method to the Home controller that produces a sequence of objects.

Listing 21-24. Adding an Action in the HomeController.cs File in the Controllers Folder
```cs
using Microsoft.AspNetCore.Mvc;
using WebApp.Models;

namespace WebApp.Controllers 
{
	public class HomeController : Controller 
	{
		private DataContext context;
		
		public HomeController(DataContext ctx) 
		{
			context = ctx;
		}
		
		public async Task<IActionResult> Index(long id = 1) 
		{
			Product? prod = await context.Products.FindAsync(id);
			if (prod?.CategoryId == 1) 
			{
				return View("Watersports", prod);
			}
			else 
			{
				return View(prod);
			}
		}
		
		public IActionResult Common() 
		{
			return View();
		}

		public IActionResult List() 
		{
			return View(context.Products);
		}
	}
}
```

The new action is called *List*, and it provides its view with the sequence of *Product* objects obtained from the Entity Framework Core data context. Add a Razor View file named List.cshtml to the *Views/Home* folder and add the content shown in Listing 21-25.

Listing 21-25. The Contents of the List.cshtml File in the Views/Home Folder
```html
@model IEnumerable<Product>
<!DOCTYPE html>
<html>
	<head>
		<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
	</head>
	<body>
		<h6 class="bg-secondary text-white text-center m-2 p-2">Products</h6>
		<div class="m-2">
			<table class="table table-sm table-striped table-bordered">
				<thead>
					<tr><th>Name</th><th>Price</th></tr>
				</thead>
				<tbody>
					@foreach (Product p in Model ?? Enumerable.Empty<Product>()) 
					{
						<tr>
							<td>@p.Name</td><td>@p.Price</td>
						</tr>
					}
				</tbody>
			</table>
		</div>
	</body>
</html>
```

The `foreach` expression follows the same format as the C# `foreach` statement, and I used the `??` operator to fall back to an empty collection when the model is `null`. In the example, the variable p is assigned each object in the sequence provided by the action method. The content within the expression is duplicated for each object and inserted into the response after the expressions it contains are evaluated. In this case, the content in the foreach expression generates a table row with cells that have their own expressions.
```html
<td>@p.Name</td><td>@p.Price</td>
```

# Using Razor Code Blocks

Code blocks are regions of C# content that do not generate content but that can be useful to perform tasks that support the expressions that do. Listing 21-26 adds a code block that calculates an average value.

> The most common use of code blocks is to select a layout, which is described in Chapter 22.

Listing 21-26. Using a Code Block in the List.cshtml File in the Views/Home Folder
```html
@model IEnumerable<Product>
@{
	decimal average = Model?.Average(p => p.Price) ?? 0;
}

<!DOCTYPE html>
<html>
<head>
	<link href="/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body>
	<h6 class="bg-secondary text-white text-center m-2 p-2">Products</h6>
	<div class="m-2">
		<table class="table table-sm table-striped table-bordered">
			<thead>
				<tr><th>Name</th><th>Price</th></tr>
			</thead>
			<tbody>
				@foreach (Product p in Model ?? Enumerable.Empty<Product>()) 
				{
					<tr>
					<td>@p.Name</td><td>@p.Price</td>
					<td>@((p.Price / average * 100).ToString("F1")) % of average</td>
					</tr>
				}
			</tbody>
		</table>
	</div>
</body>
</html>
```

The code block is denoted by `@{` and `}` and contains standard C# statements. The code block in Listing 21-26 uses LINQ to calculate a value that is assigned to a variable named average, which is used in an expression to set the contents of a table cell, avoiding the need to repeat the average calculation for each object in the view model sequence. 

> ![[zICO - Warning - 16.png]] Code blocks can become difficult to manage if they contain more than a few statements. For more complex tasks, consider using the view bag, described in Chapter 22, or adding a nonaction method to the controller.