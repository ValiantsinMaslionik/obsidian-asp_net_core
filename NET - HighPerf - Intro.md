#net/performance 

---

# Уровни оптимизации NET приложения

![[zIMG-netperf-intro-01.png]]

Верхний уровень — это архитектура вашей системы, будь то отдельное приложение или массив совместно работающих приложений, охватывающий весь дата-центр. Именно здесь начинается оптимизация производительности, поскольку **архитектура оказывает наибольшее потенциальное влияние на общую производительность**. Изменение архитектуры приводит к резкому изменению всех слоев, расположенных ниже, поэтому сначала следует убедиться, что у вас есть право на это изменение. Только после этого нужно перемещаться вниз по слоям.

Ниже располагается код, то есть алгоритмы, используемые для обработки данных. Здесь и происходят главные неприятности. На этом уровне встречается основная масса функциональных ошибок и просчетов, снижающих производительность. Это простое правило перекликается с аналогичным правилом отладки: **опытный программист всегда будет считать, что ошибочен его собственный код, и не станет обвинять компилятор, платформу, операционную систему или оборудование**. Это, безусловно, относится и к оптимизации производительности.

Ниже вашего кода находится среда .NET Framework — набор классов, предоставляемых компанией Microsoft или сторонними организациями и предлагающих стандартные функциональные возможности для обработки строк, коллекций и производства параллельных вычислений. Там же находятся такие полнофункциональные подплатформы для разработки определенных классов приложений, как Windows Communication Framework, Windows Presentation Foundation и т. д. Вам не удастся избежать использования как минимум некоторой части среды, но применение большинства частей не обязательно. Большая часть среды реализована с помощью управляемого кода, точно такой же управляемый код есть и в вашем собственном приложении. Код среды можно даже прочитать в Интернете по адресу http://referencesource.microsoft.com/ или из среды Visual Studio.

Под классами среды .NET Framework находится настоящая рабочая лошадка .NET — среда Common Language Runtime (CLR). Она представляет собой сочетание управляемых и неуправляемых компонентов, обеспечивающих такие сервисы, как сборка мусора, загрузка типов, JIT-компиляция и множество других деталей реализации среды .NET.

Еще ниже код, образно говоря, достигает «железа». После того как среда CLR выполнит JIT-компиляцию кода, вы фактически запускаете ассемблерный код процессора. Если пробраться в управляемый процесс с помощью отладчика машинного кода, можно увидеть исполняемый ассемблерный код. В этом заключается суть управляемого кода — используются обыкновенные машинные ассемблерные инструкции, выполняемые в контексте особо надежной среды.

>Повторю еще раз: при проектировании высокопроизводительных приложений или их исследовании всегда следует начинать с верхнего уровня и двигаться вниз. Прежде чем ковыряться в деталях базового кода, убедитесь в целесообразности структуры и алгоритмов вашей программы. **Макрооптимизация практически всегда выгоднее микрооптимизации.**

# Хронология совершенствования производительности среды .NET

Разработка сред CLR и .NET Framework продолжается по сей день, и со времени выхода в начале 2002 года версии 1.0 в них были внесены весьма существенные улучшения. В этом разделе задокументированы некоторые наиболее важные изменения, особенно те, что касаются повышения производительности.

- 1.0 (2002).
- 1.1 (2003).
	- Появление поддержки IPv6.
	- Появление возможности установки нескольких версий .NET на одном компьютере и выполнения программ на предопределенной версии платформы.
	- Повышение безопасности.
- 2.0 (2006).
	- Появление поддержки 64-разрядных систем (как x64, так и уже практически неактуальной IA-64).
	- Появление типов, допускающих значение null.
	- Появление анонимных методов.
	- Появление итераторов.
	- Появление обобщений и классов обобщенных коллекций.
	- Повышение производительности работы с кодировкой UTF-8.
	- Улучшение класса Semaphore.
	- Улучшения в сборщике мусора (GC):
	- уменьшение фрагментации, вызванной закреплением объектов;
	- уменьшение числа OutOfMemoryExceptions.
- 3.0 (2006).
	- Введение Windows Presentation Foundation (WPF), Windows Communication Foundation (WCF), Windows Workflow Foundation (WF).
- 3.5 (2007).
	- Появление LINQ и методов для работы с LINQ по всей библиотеке классов.
- 3.5 SP1 (2008).
	- Существенное повышение производительности WPF за счет, кроме всего прочего, аппаратной отрисовки, улучшения побитового отображения и отрисовки текстовых символов.
- 4.0 (2010).
	- Появление библиотеки параллельных задач (Task Parallel Library).
	- Появление Parallel LINQ (PLINQ).
	- Появление диспетчеризации методов с помощью dynamic.
	- Появление именованных и необязательных параметров.
	- Усовершенствование фоновой сборки мусора в режиме рабочей станции.
- 4.5 (2012).
	- Введение истечения срока ожидания разрешения регулярных выражений.
	- Появление async и await.
	- Усовершенствование GC:
	- появление фоновой сборки мусора в режиме сервера;
	- появление балансировки кучи больших объектов для сборки мусора в режиме сервера;
	- улучшение поддержки систем более чем с 64 процессорами;
	- появление устойчивого режима с низким уровнем задержки;
	- уменьшение фрагментации LOH;
	- появление поддержки наборов данных, превышающих 2 Гбайт.
	- Появление многоядерной JIT-компиляции для сокращения времени запуска.
	- Добавление `WeakReference<T>`.
- 4.5.1 (2013).
	- Появление усовершенствованной поддержки отладки, особенно для кода x64.
	- Автоматическое перенаправление привязки сборок.
	- Появление явного уплотнения LOH.
- 4.5.2 (2014).
	- Улучшение ETW.
	- Улучшение поддержки профилирования.
- 4.6 (2015).
	- Улучшение 64-разрядной JIT-компиляции (кодовое имя RyuJIT), появление поддержки инструкций SSE2 и AVX2.
	- Добавление областей No-GC.
- 4.6.1 (2015).
	- Повышение производительности сборщика мусора.
	- Повышение производительности JIT-компилятора.
- 4.6.2 (2016).
	- Разрешение использования имен путей длиннее 260 символов.
	- Повышение производительности и надежности JIT-компилятора.
	- Существенное исправление ошибок в EventSource.
	- Улучшения в GC:
		- появление возможности сборки всех объектов, следующих за закрепленными объектами;
		- более эффективное использование свободного пространства gen 2.
- 4.7 (2017).
	 - Повышение производительности JIT-компилятора.
	- Появление дополнительных вариантов конфигурации GC.
	- Появление типа ValueTuple.
- 4.7.1 (2017).
	- Улучшение сборки мусора за счет скорости выделения памяти в LOH. Выделение памяти в LOH больше не блокируется развертыванием полной фоновой сборки мусора.
- 4.7.2 (2018).
	- Повышение производительности `HashSet<T>` и `ConcurrentDictionary<TKey, TValue>`.
	- Повышение производительности `ReaderWriterLockSlim` и `ManualResetEventSlim`.
	- Повышение производительности сборки мусора.
