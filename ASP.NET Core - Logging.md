#ASP_NET_CORE/Platform/Logging

---

ASP.NET Core provides a logging service that can be used to record messages that describe the state of the application to track errors, monitor performance, and help diagnose problems. Log messages are sent to logging providers, which are responsible for forwarding messages to where they can be seen, stored, and processed. There are built-in providers for basic logging, and there is a range of third-party providers available for feeding messages into logging frameworks that allow messages to be collated and analyzed.
Three of the built-in providers are enabled by default: the *console provider*, the *debug provider*, and the *EventSource* provider. 
The *debug provider* forwards messages so they can be processed through the `System.Diagnostics.Debug` class, 
and the *EventSource* provider forwards messages for event tracing tools, such as *PerfView* (https://github.com/Microsoft/perfview). 

I use the console provider in this chapter because it is simple and doesn’t require any additional configuration to display logging messages.

> You can see the list of providers available and instructions for enabling them at https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging.

## Generating Logging Messages

To prepare for this section, Listing 15-19 reconfigures the application to remove the services, middleware, and endpoints from the previous section.
```cs
using Platform;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("population/{city?}", Population.Endpoint);

app.Run();
```

Logging messages are generated using the unbounded `ILogger<>` service, as shown in Listing 15-20. ^46f16a
```cs
namespace Platform 
{
	public class Population 
	{
		public static async Task Endpoint(HttpContext context, ILogger<Population> logger) 
		{
			logger.LogDebug($"Started processing for {context.Request.Path}");
			
			string city = context.Request.RouteValues["city"] as string ?? "london";
			int? pop = null;
			
			switch (city.ToLower()) 
			{
				case "london":
					pop = 8_136_000;
					break;
				case "paris":
					pop = 2_141_000;
					break;
				case "monaco":
					pop = 39_000;
					break;
			}
			
			if (pop.HasValue) 
			{
				await context.Response.WriteAsync($"City: {city}, Population: {pop}");
			}
			else 
			{
				context.Response.StatusCode = StatusCodes.Status404NotFound;
			}
			
			logger.LogDebug($"Finished processing for {context.Request.Path}");
		}
	}
}
```

The logging service groups log messages together based on the category assigned to messages. Log messages are written using the `ILogger<T>` interface, where the generic parameter `T` is used to specify the category. 

> The convention is to use the type of the class that generates the messages as the category type, which is why Listing 15-20 declares a dependency on the service using `Population` for the type argument

This ensures that log messages generated by the `Endpoint` method will be assigned the category `Population`. Log messages are created using the extension methods shown in Table 15-4.

Name|Description
--|--
LogTrace|This method generates a Trace-level message, used for low-level debugging during development.
LogDebug|This method generates a Debug-level message, used for low-level debugging during development or production problem resolution.
LogInformation|This method generates an Information-level message, used to provide information about the general state of the application.
LogError|This method generates an Error-level message, used to record exceptions or errors that are not handled by the application.
LogCritical|This method generates a Critical-level message, used to record serious failures.

Log messages are assigned a level that reflects their importance and detail. The levels range from *Trace*, for detailed diagnostics, to *Critical*, for the most important information that requires an immediate response. There are overloaded versions of each method that allow log messages to be generated using strings or exceptions. In Listing 15-20, I used the `LogDebug` method to generate logging messages when a request is handled.

The result is log messages at the *Debug* level that are generated when the response is started and completed. To see the log messages, restart ASP.NET Core and use a browser to request http://localhost:5000/population. Look at the console output, and you will see the log messages in the output from ASP.NET Core, like this:
```
Building...
info: Microsoft.Hosting.Lifetime[14]
Now listening on: http://localhost:5000
info: Microsoft.Hosting.Lifetime[0]
Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
Content root path: C:\Platform
dbug: Platform.Population[0]
Started processing for /population
dbug: Platform.Population[0]
Finished processing for /population
```

## Logging Messages in the Program.cs File

The `Logger<>` service is useful for logging in classes but isn’t suited to logging in the *Program.cs* file, where top-level statements are used to configure the application. The simplest approach is to use the `ILogger` returned by the `Logger` property defined by the `WebApplication` class, as shown in Listing 15-21.
```cs
using Platform;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.Logger.LogDebug("Pipeline configuration starting");
app.MapGet("population/{city?}", Population.Endpoint);
app.Logger.LogDebug("Pipeline configuration complete");

app.Run();
```
```txt
Building...
dbug: Platform[0]
Pipeline configuration starting
dbug: Platform[0]
Pipeline configuration complete
info: Microsoft.Hosting.Lifetime[14]
Now listening on: http://localhost:5000
info: Microsoft.Hosting.Lifetime[0]
Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
Content root path: C:\Platform
```

The category for logging messages generated using the `ILogger` provided by the `WebApplication` class is the name of the application, which is *Platform* for this example. If you want to generate log messages with a different category, which can be useful in lambda functions, for example, then you can use the `ILoggerFactory` interface, which is available as a service, and call the `CreateLogger` method to obtain an `ILogger` for a specified category, as shown in Listing 15-22. ^e20a95
```cs
using Platform;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
var logger = app.Services.GetRequiredService<ILoggerFactory>().CreateLogger("Pipeline");

logger.LogDebug("Pipeline configuration starting");
app.MapGet("population/{city?}", Population.Endpoint);
logger.LogDebug("Pipeline configuration complete");

app.Run();
```
```txt
Building...
dbug: Pipeline[0]
Pipeline configuration starting
dbug: Pipeline[0]
Pipeline configuration complete
Chapter 15 ■ Using the Platform Features, Part 1
413
info: Microsoft.Hosting.Lifetime[14]
Now listening on: http://localhost:5000
info: Microsoft.Hosting.Lifetime[0]
Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
Content root path: C:\Platform
```

## Logging Messages with Attributes

An alternative approach to generating log messages is to use the `LoggerMessage` attribute, as shown in Listing 15-23.
```cs
namespace Platform 
{
	public partial class Population 
	{
		public static async Task Endpoint(HttpContext context, ILogger<Population> logger) 
		{
			StartingResponse(logger, context.Request.Path);
			
			string city = context.Request.RouteValues["city"] as string ?? "london";
			int? pop = null;
			
			switch (city.ToLower()) 
			{
				case "london":
					pop = 8_136_000;
					break;
				case "paris":
					pop = 2_141_000;
					break;
				case "monaco":
					pop = 39_000;
					break;
			}
			
			if (pop.HasValue) 
			{
				await context.Response.WriteAsync($"City: {city}, Population: {pop}");
			}
			else
			{
				context.Response.StatusCode = StatusCodes.Status404NotFound;
			}
			
			logger.LogDebug($"Finished processing for {context.Request.Path}");
		}
		
		[LoggerMessage(0, LogLevel.Debug, "Starting response for {path}")]
		public static partial void StartingResponse(ILogger logger, string path);
	}
}
```

The `LoggerMessage` attribute is applied to partial methods, which must be defined in partial classes. When the application is compiled, the attribute generates the implementation for the method to which it is applied, resulting in logging, **which Microsoft says offers better performance than the other techniques described in this section**. Full details of how this feature works can be found at https://docs.microsoft.com/en-us/dotnet/core/extensions/logger-message-generator.

> I do not doubt Microsoft’s assertion that using the `LoggerMessage` attribute is faster, but I doubt it matters for most projects. Use the attribute if you find this approach easier to understand and maintain, but don’t rush to adopt it just for the sake of a performance gain unless you have an application that doesn’t meet its performance goals and you are sure that logging performance is contributing to the problem. I am confident that this will never be the case for most projects because of the nature of most web applications, but please get
in touch if you find yourself in this position because I am always willing to have my assumptions proven wrong.

```txt
dbug: Platform.Population[0]
Starting response for /population
dbug: Platform.Population[0]
Finished processing for /population
```

## Configuring Minimum Logging Levels

In Chapter 14, I showed you the default contents of the appsettings.json and `appsettings.Development.json` files and explained how they are merged to create the application’s configuration settings. The settings in the JSON file are used to configure the logging service, which ASP.NET Core provides to record messages about the state of the application.

The *Logging:LogLevel* section of the *appsettings.json* file is used to set the minimum level for logging messages. 
Log messages that are below the minimum level are discarded. The *appsettings.json* file contains the following levels:
```json
"Default": "Information",
"Microsoft.AspNetCore": "Warning"
```

The category for the log messages — which is set using the generic type argument as in [[#^46f16a|Listing 15-20]] or using a string, as in [[#^e20a95|Listing 15-22]] — is used to select a minimum filter level.

> For the log messages generated by the `Population` class, for example, the category will be `Platform.Population`, which means that they can be matched directly by adding a *Platform.Population* entry to the *appsettings.json* file or indirectly by specifying just the *Platform* namespace. 

Any category for which there is no minimum log level is matched by the *Default* entry, which is set to *Information*. It is common to increase the detail of the log messages displayed during development, which is why the levels in the *appsettings.Development.json* file specify more detailed logging levels, like this:
```json
"Default": "Debug",
"System": "Information",
"Microsoft": "Information"
```

> When the application is configured for the *Development* environment, the default logging level is *Debug*. 

> The levels for the *System* and *Microsoft* categories are set to *Information*, which affects the logging messages generated by ASP.NET Core and the other packages and frameworks provided by Microsoft. 

> You can tailor the logging levels to focus the log on those parts of the application that are of interest by setting a level to *Trace*, *Debug*, *Information*, *Error*, or *Critical*. Logging messages can be disabled for a category using the *None* value.

Listing 15-24 sets the level to *Debug* for the *Microsoft.AspNetCore* setting, which will increase the default level of detail and will have the effect of displaying debug-level messages generated by ASP.NET Core.
```json
{
	"Logging": {
		"LogLevel": {
			"Default": "Debug",
			"System": "Information",
			"Microsoft": "Information",
			"Microsoft.AspNetCore": "Debug"
		}
	}
}
```

You can reduce the detail by being more specific about the namespace for which messages are required, as shown in Listing 15-25.
```json
{
	"Logging": {
		"LogLevel": {
			"Default": "Debug",
			"System": "Information",
			"Microsoft": "Information",
			"Microsoft.AspNetCore": "Warning",
			"Microsoft.AspNetCore.Routing": "Debug"
		}
	}
}
```

The changes return the *Microsoft.AspNetCore* category to *Warning* and set the *Microsoft.AspNetCore.Routing* category to *Debug*, which increases the detail level for logging messages by the components responsible for routing. 
```txt
dbug: Microsoft.AspNetCore.Routing.Matching.DfaMatcher[1001]
1 candidate(s) found for the request path '/population'
dbug: Microsoft.AspNetCore.Routing.Matching.DfaMatcher[1005]
Endpoint 'HTTP: GET population/{city?} => Endpoint' with route pattern 'population/
{city?}' is valid for the request path '/population'
dbug: Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware[1]
Request matched endpoint 'HTTP: GET population/{city?} => Endpoint'
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
Executing endpoint 'HTTP: GET population/{city?} => Endpoint'
dbug: Platform.Population[0]
Starting response for /population
dbug: Platform.Population[0]
Finished processing for /population
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
Executed endpoint 'HTTP: GET population/{city?} => Endpoint'
```

If you are having trouble figuring out a routing scheme, then these messages can be helpful in figuring out what the application is doing with requests.

## Logging HTTP Requests and Responses

ASP.NET Core includes built-in middleware for generating log messages that describe the HTTP requests received by an application and the responses it produces. Listing 15-26 adds the HTTP logging middleware to the request pipeline.
```cs
using Platform;

var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();
app.UseHttpLogging();

app.MapGet("population/{city?}", Population.Endpoint);

app.Run();
```

The `UseHttpLogging` method adds a middleware component that generates logging messages that describe the HTTP requests and responses. These log messages are generated with the *Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware* category and the Information severity, which I have enabled in Listing 15-27.
```json
{
	"Logging": {
		"LogLevel": {
			"Default": "Debug",
			"System": "Information",
			"Microsoft": "Information",
			"Microsoft.AspNetCore": "Warning",
			"Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information"
		}
	}
}
```
```txt
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]
Request:
Protocol: HTTP/1.1
Method: GET
Scheme: http
PathBase:
Path: /population
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,
image/avif,image/webp,image/apng,*/*;q=0.8,
application/signed-exchange;v=b3;q=0.9
Connection: keep-alive
Host: localhost:5000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36
Accept-Encoding: gzip, deflate, br
Accept-Language: en-GB,en-US;q=0.9,en;q=0.8
Cache-Control: [Redacted]
Cookie: [Redacted]
Upgrade-Insecure-Requests: [Redacted]
sec-ch-ua: [Redacted]
sec-ch-ua-mobile: [Redacted]
sec-ch-ua-platform: [Redacted]
Sec-Fetch-Site: [Redacted]
Sec-Fetch-Mode: [Redacted]
Sec-Fetch-User: [Redacted]
Sec-Fetch-Dest: [Redacted]
dbug: Platform.Population[0]
Starting response for /population
dbug: Platform.Population[0]
Finished processing for /population
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]
Response:
StatusCode: 200
Date: [Redacted]
Server: [Redacted]
Transfer-Encoding: chunked
```

The details of the HTTP request and response logging messages can be configured using the `AddHttpLogging` method, as shown in Listing 15-28.
```cs
using Platform;
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddHttpLogging(opts => 
{
	opts.LoggingFields = HttpLoggingFields.RequestMethod | HttpLoggingFields.RequestPath | HttpLoggingFields.ResponseStatusCode;
});

var app = builder.Build();
app.UseHttpLogging();

app.MapGet("population/{city?}", Population.Endpoint);

app.Run();
```

This method selects the fields and headers that are included in the logging message. The configuration in Listing 15-28 selects the method and path from the HTTP request and the status code from the response. 

> See https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-logging/?view=aspnetcore-6.0 for the complete set of configuration options for HTTP logging.

```txt
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]
Request:
Method: GET
PathBase:
Path: /population
dbug: Platform.Population[0]
Starting response for /population
dbug: Platform.Population[0]
Finished processing for /population
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]
Response:
StatusCode: 200
```

> ASP .NET Core also provides middleware that will generate log messages in the W3C format. See https://docs.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/?view=aspnetcore-6.0 for details.